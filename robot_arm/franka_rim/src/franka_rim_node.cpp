#include "franka_rim/franka_rim_node.hpp"

#include <cstring>
#include <iostream>
namespace {

// Example implementation of bit_cast: https://en.cppreference.com/w/cpp/numeric/bit_cast
template <class To, class From>
std::enable_if_t<sizeof(To) == sizeof(From) && std::is_trivially_copyable<From>::value &&
                     std::is_trivially_copyable<To>::value,
                 To>
bit_cast(const From& src) noexcept {
  static_assert(std::is_trivially_constructible<To>::value,
                "This implementation additionally requires "
                "destination type to be trivially constructible");

  To dst;
  std::memcpy(&dst, &src, sizeof(To));
  return dst;
}

}  // namespace

FrankaRimNode::FrankaRimNode()
  : Node("franka_rim_node")
{
    RCLCPP_INFO(this->get_logger(), "Starting FrankaRimNode...");
//   this->declare_parameter<std::string>("model_source_path", "");
//   this->get_parameter("model_source_path", model_source_path_value_);
//   RCLCPP_INFO(this->get_logger(), "Model source path: %s", model_source_path_value_.c_str());

  // * Initialize franka_model_
  // TODO: Initialize franka_model_ here.
  // The method for initializing franka::Model depends on your setup:
  // 1. If you have a franka::Robot object (e.g., in a control node):
    //  franka_model_ = robot.loadModel();
  // 2. If loading from a specific model file generated by/for libfranka
  //    (note: franka::Model does not directly parse raw URDFs for dynamics):
     // franka_model_ = std::make_shared<franka::Model>(model_source_path_value, franka::Frame::kEndEffector, franka::Frame::kFlange); // Example, adapt as needed
  // 3. If franka_ros2 provides a service or mechanism to get the model.
  // Ensure franka_model_ is valid before use in callbacks.
  // For now, we'll proceed assuming it will be initialized.
  // auto franka_model_interface;

  // robot_model_ = bit_cast<franka_hardware::Model*>((*franka_model_interface).get().get_value());


  // * Initialize pub/sub
  joint_state_subscriber_ = this->create_subscription<sensor_msgs::msg::JointState>(
    "/joint_states", 10, std::bind(&FrankaRimNode::jointStatesCallback, this, std::placeholders::_1));

  mass_matrix_publisher_ = this->create_publisher<std_msgs::msg::Float64MultiArray>("~/mass_matrix", 10);
  coriolis_vector_publisher_ = this->create_publisher<std_msgs::msg::Float64MultiArray>("~/coriolis_vector", 10);
  gravity_vector_publisher_ = this->create_publisher<std_msgs::msg::Float64MultiArray>("~/gravity_vector", 10);


  RCLCPP_INFO(this->get_logger(), "FrankaRimNode initialized successfully.");
}

void FrankaRimNode::jointStatesCallback(const sensor_msgs::msg::JointState::SharedPtr msg) {
    if (!franka_model_) {
        RCLCPP_ERROR_ONCE(this->get_logger(), "franka_model_ is not initialized. Dynamics computation skipped.");
        return;
    }
    if (msg->position.size() < 7 || msg->velocity.size() < 7 || msg->name.size() < 7) {
        RCLCPP_ERROR(this->get_logger(), "JointState message does not contain enough elements for 7-DoF Franka arm.");
        return;
    }
    std::array<double, 7> q;
    std::array<double, 7> dq;
    for (size_t i = 0; i < 7; ++i) {
        q[i] = msg->position[i];
        dq[i] = msg->velocity[i];
    }
    // std::array<double, 49> mass_m = franka_model_->mass(q);
    // std::array<double, 7> coriolis_v = franka_model_->coriolis(q, dq);
    // std::array<double, 7> gravity_v = franka_model_->gravity(q);

    std::array<double, 49> mass_m = {};
    std::array<double, 7> coriolis_v = {};
    std::array<double, 7> gravity_v = {};

    std_msgs::msg::Float64MultiArray mass_msg;
    mass_msg.layout.dim.resize(2);
    mass_msg.layout.dim[0].label = "rows";
    mass_msg.layout.dim[0].size = 7;
    mass_msg.layout.dim[0].stride = 49;
    mass_msg.layout.dim[1].label = "cols";
    mass_msg.layout.dim[1].size = 7;
    mass_msg.layout.dim[1].stride = 7;
    mass_msg.layout.data_offset = 0;
    mass_msg.data.assign(mass_m.begin(), mass_m.end());
    mass_matrix_publisher_->publish(mass_msg);

    std_msgs::msg::Float64MultiArray coriolis_msg;
    coriolis_msg.layout.dim.resize(1);
    coriolis_msg.layout.dim[0].label = "elements";
    coriolis_msg.layout.dim[0].size = 7;
    coriolis_msg.layout.dim[0].stride = 7;
    coriolis_msg.layout.data_offset = 0;
    coriolis_msg.data.assign(coriolis_v.begin(), coriolis_v.end());
    coriolis_vector_publisher_->publish(coriolis_msg);

    std_msgs::msg::Float64MultiArray gravity_msg;
    gravity_msg.layout.dim.resize(1);
    gravity_msg.layout.dim[0].label = "elements";
    gravity_msg.layout.dim[0].size = 7;
    gravity_msg.layout.dim[0].stride = 7;
    gravity_msg.layout.data_offset = 0;
    gravity_msg.data.assign(gravity_v.begin(), gravity_v.end());
    gravity_vector_publisher_->publish(gravity_msg);
}

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<FrankaRimNode>());
  rclcpp::shutdown();
  return 0;
}
