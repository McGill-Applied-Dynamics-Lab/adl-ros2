#include "franka_rim/franka_rim_node.hpp"

#include <cstring>
#include <iostream>

#include "hardware_interface/types/hardware_interface_return_values.hpp"
#include "hardware_interface/types/hardware_interface_type_values.hpp"

namespace {

// Example implementation of bit_cast: https://en.cppreference.com/w/cpp/numeric/bit_cast
template <class To, class From>
std::enable_if_t<sizeof(To) == sizeof(From) && std::is_trivially_copyable<From>::value &&
                     std::is_trivially_copyable<To>::value,
                 To>
bit_cast(const From& src) noexcept {
  static_assert(std::is_trivially_constructible<To>::value,
                "This implementation additionally requires "
                "destination type to be trivially constructible");

  To dst;
  std::memcpy(&dst, &src, sizeof(To));
  return dst;
}

// std::vector<hardware_interface::LoanedStateInterface> to_value_vector(std::vector<std::reference_wrapper<hardware_interface::LoanedStateInterface>> state_interfaces_)
// {
//   std::vector<hardware_interface::LoanedStateInterface> result;
//   result.reserve(state_interfaces_.size());
//   for (const auto & ref : state_interfaces_)
//   {
//     result.emplace_back(ref.get());
//   }
//   return result;
// }

}  // namespace

FrankaRimNode::FrankaRimNode()
  : Node("franka_rim_node"), SemanticComponentInterface("fr3/robot_model", 2)
{
    RCLCPP_INFO(this->get_logger(), "Starting FrankaRimNode...");
//   this->declare_parameter<std::string>("model_source_path", "");
//   this->get_parameter("model_source_path", model_source_path_value_);
//   RCLCPP_INFO(this->get_logger(), "Model source path: %s", model_source_path_value_.c_str());

  // * Initialize franka_model_
  // TODO: Initialize franka_model_ here.
  franka_robot_model_ = std::make_unique<franka_rim::FrankaRobotModel>(
      franka_rim::FrankaRobotModel(arm_id_ + "/" + k_robot_model_interface_name,
                                                   arm_id_ + "/" + k_robot_state_interface_name));


  // The method for initializing franka::Model depends on your setup:
  // 1. If you have a franka::Robot object (e.g., in a control node):
    //  franka_model_ = robot.loadModel();
  // 2. If loading from a specific model file generated by/for libfranka
  //    (note: franka::Model does not directly parse raw URDFs for dynamics):
     // franka_model_ = std::make_shared<franka::Model>(model_source_path_value, franka::Frame::kEndEffector, franka::Frame::kFlange); // Example, adapt as needed
  // 3. If franka_ros2 provides a service or mechanism to get the model.
  // Ensure franka_model_ is valid before use in callbacks.
  // For now, we'll proceed assuming it will be initialized.
  // auto franka_model_interface;
  // size_t state_interface_size = 1; // Adjust this based on your actual state interfaces
  // state_interfaces_.reserve(state_interface_size);

    // const std::string& franka_model_interface_name_ = "fr3/robot_model";
    // interface_names_.emplace_back(franka_model_interface_name_);

    // model_interfaces_.reserve(1);
    // model_interfaces_.emplace_back(franka_model_interface_name_);
    

    // // this->assign_loaned_state_interfaces(model_interfaces_);

    // auto franka_model_interface =
    //     std::find_if(state_interfaces_.begin(), state_interfaces_.end(), [&](const auto& interface) {
    //       return interface.get().get_name() == franka_model_interface_name_;
    //     });

    // robot_model_ = bit_cast<franka_hardware::Model*>((*franka_model_interface).get().get_value());

    // if (franka_model_interface != state_interfaces_.end()) {
    //   robot_model_ = bit_cast<franka_hardware::Model*>((*franka_model_interface).get().get_value());
    // } else {
    //   RCLCPP_ERROR(this->get_logger(),
    //               "Franka interface does not exist! Did you assign the loaned state in the "
    //               "controller?");
    //   throw std::runtime_error("Franka state interfaces does not exist");
    // }


  // auto franka_model_interface =
  //     std::find_if(state_interfaces_.begin(), state_interfaces_.end(), [&](const auto& interface) {
  //       return interface.get().get_name() == franka_model_interface_name_;
  //     });

  // robot_model_ = bit_cast<franka_hardware::Model*>((*franka_model_interface).get().get_value());
        std::array<double, 49> mass = franka_robot_model_->getMassMatrix();
  std::array<double, 7> coriolis = franka_robot_model_->getCoriolisForceVector();
  std::array<double, 7> gravity = franka_robot_model_->getGravityForceVector();
  std::array<double, 16> pose = franka_robot_model_->getPoseMatrix(franka::Frame::kJoint4);
  std::array<double, 42> joint4_body_jacobian_wrt_joint4 =
      franka_robot_model_->getBodyJacobian(franka::Frame::kJoint4);
  std::array<double, 42> endeffector_jacobian_wrt_base =
      franka_robot_model_->getZeroJacobian(franka::Frame::kEndEffector);

  RCLCPP_INFO(this->get_logger(), "-------------------------------------------------------------");

  // RCLCPP_INFO_STREAM(this->get_logger(), "FrankaRimNode initialized with arm_id: " << arm_id_);

  // RCLCPP_INFO_STREAM(this->get_logger(), "mass :" << mass);
  // RCLCPP_INFO_STREAM_THROTTLE(this->get_logger(), *this->get_clock(), 1000,
  //                             "coriolis :" << coriolis);
  // RCLCPP_INFO_STREAM_THROTTLE(this->get_logger(), *this->get_clock(), 1000,
  //                             "gravity :" << gravity);
  // RCLCPP_INFO_STREAM_THROTTLE(this->get_logger(), *this->get_clock(), 1000,
  //                             "joint_pose :" << pose);
  // RCLCPP_INFO_STREAM_THROTTLE(
  //     this->get_logger(), *this->get_clock(), 1000,
  //     "joint4_body_jacobian in joint4 frame :" << joint4_body_jacobian_wrt_joint4);
  // RCLCPP_INFO_STREAM_THROTTLE(
  //     this->get_logger(), *this->get_clock(), 1000,
  //     "end_effector_jacobian in base frame :" << endeffector_jacobian_wrt_base);
  // RCLCPP_INFO(this->get_logger(), *this->get_clock(), 1000,
                      //  "-------------------------------------------------------------");



  // * Initialize pub/sub
  joint_state_subscriber_ = this->create_subscription<sensor_msgs::msg::JointState>(
    "/joint_states", 10, std::bind(&FrankaRimNode::jointStatesCallback, this, std::placeholders::_1));

  mass_matrix_publisher_ = this->create_publisher<std_msgs::msg::Float64MultiArray>("~/mass_matrix", 10);
  coriolis_vector_publisher_ = this->create_publisher<std_msgs::msg::Float64MultiArray>("~/coriolis_vector", 10);
  gravity_vector_publisher_ = this->create_publisher<std_msgs::msg::Float64MultiArray>("~/gravity_vector", 10);


  RCLCPP_INFO(this->get_logger(), "FrankaRimNode initialized successfully.");
}

void FrankaRimNode::jointStatesCallback(const sensor_msgs::msg::JointState::SharedPtr msg) {
    if (!franka_model_) {
        RCLCPP_ERROR_ONCE(this->get_logger(), "franka_model_ is not initialized. Dynamics computation skipped.");
        return;
    }
    if (msg->position.size() < 7 || msg->velocity.size() < 7 || msg->name.size() < 7) {
        RCLCPP_ERROR(this->get_logger(), "JointState message does not contain enough elements for 7-DoF Franka arm.");
        return;
    }
    std::array<double, 7> q;
    std::array<double, 7> dq;
    for (size_t i = 0; i < 7; ++i) {
        q[i] = msg->position[i];
        dq[i] = msg->velocity[i];
    }
    // std::array<double, 49> mass_m = franka_model_->mass(q);
    // std::array<double, 7> coriolis_v = franka_model_->coriolis(q, dq);
    // std::array<double, 7> gravity_v = franka_model_->gravity(q);

    std::array<double, 49> mass_m = {};
    std::array<double, 7> coriolis_v = {};
    std::array<double, 7> gravity_v = {};

    std_msgs::msg::Float64MultiArray mass_msg;
    mass_msg.layout.dim.resize(2);
    mass_msg.layout.dim[0].label = "rows";
    mass_msg.layout.dim[0].size = 7;
    mass_msg.layout.dim[0].stride = 49;
    mass_msg.layout.dim[1].label = "cols";
    mass_msg.layout.dim[1].size = 7;
    mass_msg.layout.dim[1].stride = 7;
    mass_msg.layout.data_offset = 0;
    mass_msg.data.assign(mass_m.begin(), mass_m.end());
    mass_matrix_publisher_->publish(mass_msg);

    std_msgs::msg::Float64MultiArray coriolis_msg;
    coriolis_msg.layout.dim.resize(1);
    coriolis_msg.layout.dim[0].label = "elements";
    coriolis_msg.layout.dim[0].size = 7;
    coriolis_msg.layout.dim[0].stride = 7;
    coriolis_msg.layout.data_offset = 0;
    coriolis_msg.data.assign(coriolis_v.begin(), coriolis_v.end());
    coriolis_vector_publisher_->publish(coriolis_msg);

    std_msgs::msg::Float64MultiArray gravity_msg;
    gravity_msg.layout.dim.resize(1);
    gravity_msg.layout.dim[0].label = "elements";
    gravity_msg.layout.dim[0].size = 7;
    gravity_msg.layout.dim[0].stride = 7;
    gravity_msg.layout.data_offset = 0;
    gravity_msg.data.assign(gravity_v.begin(), gravity_v.end());
    gravity_vector_publisher_->publish(gravity_msg);
}

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<FrankaRimNode>());
  rclcpp::shutdown();
  return 0;
}
